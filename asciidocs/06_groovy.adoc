= Groovy basic structures and idioms

Nextflow is a DSL implemented on top of the Groovy programming lang, which in turns is a super-set of the Java programming 
language. This means that Nextflow can run any Groovy and Java code.

== Printing values

To print something is as easy as using one of the `print` or `println` methods.

[cmd,groovy,linenums]
----
println("Hello, World!")
----

The only difference between the two is that the println method implicitly appends a new line character to the printed string.

TIP: parenthesis for function invocations are optional. Therefore also the following is a valid syntax.

[cmd,groovy,linenums]
----
println "Hello, World!"
----

== Comments

Comments use the same syntax as in the C-family programming languages:

[cmd,groovy,linenums]
----
// comment a single config file

/*
   a comment spanning
   multiple lines
 */
----

== Variables

To define a variable, simply assign a value to it:

[cmd,groovy,linenums]
----
x = 1
println x

x = new java.util.Date()
println x

x = -3.1499392
println x

x = false
println x

x = "Hi"
println x
----

Local variables are defined using the `def` keyword:

[cmd,groovy,linenums]
----
def x = 'foo'
----

It should be always used when defining variables local to a function or a closure.

== Lists

A List object can be defined by placing the list items in square brackets:

[cmd,groovy,linenums]
----
list = [10,20,30,40]
----

You can access a given item in the list with square-bracket notation (indexes start at `0`) or using the `get` method:

[cmd,groovy,linenums]
----
assert list[0] == 10
assert list[0] == list.get(0)
----

In order to get the length of the list use the size method:

[cmd,groovy,linenums]
----
assert list.size() == 4
----

Lists can also be indexed with negative indexes and reversed ranges.

[cmd,groovy,linenums]
----
list = [0,1,2]
assert list[-1] == 2
assert list[-1..0] == list.reverse()
----

List objects implements all methods provided by the Java https://docs.oracle.com/javase/8/docs/api/java/util/List.html[java.util.List]
interface plus the extension methods provided by http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/List.html[Groovy API].

[cmd,groovy,linenums]
----
assert [1,2,3] << 1 == [1,2,3,1]
assert [1,2,3] + [1] == [1,2,3,1]
assert [1,2,3,1] - [1] == [2,3]
assert [1,2,3] * 2 == [1,2,3,1,2,3]
assert [1,[2,3]].flatten() == [1,2,3]
assert [1,2,3].reverse() == [3,2,1]
assert [1,2,3].collect{ it+3 } == [4,5,6]
assert [1,2,3,1].unique().size() == 3
assert [1,2,3,1].count(1) == 2
assert [1,2,3,4].min() == 1
assert [1,2,3,4].max() == 4
assert [1,2,3,4].sum() == 10
assert [4,2,1,3].sort() == [1,2,3,4]
assert [4,2,1,3].find{it%2 == 0} == 4
assert [4,2,1,3].findAll{it%2 == 0} == [4,2]
----

== Maps

Maps are like lists that have an arbitrary type of key instead of integer. Therefore, the syntax is very much aligned.

[cmd,groovy,linenums]
----
map = [a:0, b:1, c:2]
----

Maps can be accessed in a conventional square-bracket syntax or as if the key was a property of the map.

[cmd,groovy,linenums]
----
assert map['a'] == 0     // <1>     
assert map.b == 1        // <2>   
assert map.get('c') == 2 // <3>  
----

<1>	Use of the square brackets.
<2> Use a dot notation.
<3> Use of get method.

To add data or to modify a map, the syntax is similar to adding values to list:

[cmd,groovy,linenums]
----
map['a'] = 'x'      // <1>     
map.b = 'y'         // <2>     
map.put('c', 'z')   // <3>     
assert map == [a:'x', b:'y', c:'z']
----

<1>	Use of the square brackets.
<2> Use a dot notation.
<3> Use of get method.

Maps objects implements all methods provided by the Java https://docs.oracle.com/javase/8/docs/api/java/util/Map.html[java.util.Map]
interface plus the extension methods provided by http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html[Groovy API].

== String interpolation

String literals can be defined enclosing them either with single-quoted or double-quotes characters.

Double-quoted strings can contain the value of an arbitrary variable by prefixing its name with the `$` character, or the value of 
any expression by using the ${expression} syntax, similar to Bash/shell scripts:

[cmd,groovy,linenums]
----
foxtype = 'quick'
foxcolor = ['b', 'r', 'o', 'w', 'n']
println "The $foxtype ${foxcolor.join()} fox"

x = 'Hello'
println '$x + $y'
----

This code prints:

[cmd,groovy,linenums]
----
The quick brown fox
$x + $y
----

NOTE: Note the different use of `$` and `${..}` syntax to interpolate value expressions in a string literal.

Finally string literals can also be defined using the `/` character as delimiter. They are known as *slashy* 
strings and are useful for defining regular expressions and patterns, as there is no need to escape backslashes. 
As with double quote strings they allow to interpolate variables prefixed with a `$` character.

Try the following to see the difference:

[cmd,groovy,linenums]
----
x = /tic\tac\toe/
y = 'tic\tac\toe'

println x
println y
----

it prints:

[cmd,groovy,linenums]
----
tic\tac\toe
tic    ac    oe
----

== Multi-line strings

A block of text that span multiple lines can be defined by delimiting it with triple single or double quotes:

[cmd,groovy,linenums]
----
text = """
    Hello there James
    how are you today?
    """
----

Finally multi-line strings can also be defined with slashy string. For example:

[cmd,groovy,linenums]
----
text = /
    This is a multi-line
    slashy string!
    It's cool, isn't it?!
    /
----

Like before, multi-line strings inside double quotes and slash characters support variable interpolation, 
while single-quoted multi-line strings do not.

== If statement

The `if` statement uses the same syntax common other programming lang such Java, C, JavaScript, etc.

[cmd,groovy,linenums]
----
if( < boolean expression > ) {
    // true branch
}
else {
    // false branch
}
----

The `else` branch is optional. Also curly brackets are optional when the branch define just a single statement.
 
[cmd,groovy,linenums]
----
x = 1
if( x > 10 )
    println 'Hello'
----

TIP: `null`, empty strings and empty collections are evaluated to `false`.

Therefore a statement like:

[cmd,groovy,linenums]
----
list = [1,2,3]
if( list != null && list.size() > 0 ) {
  println list
}
else {
  println 'The list is empty'
}
----

Can be written as:

[cmd,groovy,linenums]
----
if( list )
    println list
else
    println 'The list is empty'
----

See the http://groovy-lang.org/semantics.html#Groovy-Truth[Groovy-Truth] for details.

TIP: In some cases can be useful to replace `if` statement with a ternary expression aka conditional expression. For example:

[cmd,groovy,linenums]
----
println list ? list : 'The list is empty'
----

The previous statement can be further simplified using the Elvis operator as shown below:

[cmd,groovy,linenums]
----
println list ?: 'The list is empty'
----

== For statement

The classical `for` loop syntax is supported as shown here:

[cmd,groovy,linenums]
----
for (int i = 0; i <3; i++) {
   println("Hello World $i")
}
----

Iteration over list objects is also possible using the syntax below:

[cmd,groovy,linenums]
----
list = ['a','b','c']

for( String elem : list ) {
  println elem
}
----

== Functions

It is possible to define a custom function into a script, as shown here:

[cmd,groovy,linenums]
----
int fib(int n) {
    return n < 2 ? 1 : fib(n-1) + fib(n-2)
}

assert fib(10)==89
----

A function can take multiple arguments separating them with a comma. The return keyword can be omitted 
and the function implicitly returns the value of the last evaluated expression. Also explicit types can 
be omitted (thought not recommended):

[cmd,groovy,linenums]
----
def fact( n ) {
  n > 1 ? n * fact(n-1) : 1
}

assert fact(5) == 120
----

== Closures

Closures are the swiss army knife of Nextflow/Groovy programming. In a nutshell a closure is is a block 
of code that can be passed as an argument to a function, it could also be defined an anonymous function.

More formally, a closure allows the definition of functions as first class objects.

[cmd,groovy,linenums]
----
square = { it * it }
----

The curly brackets around the expression `it * it` tells the script interpreter to treat this expression as code. 
The `it` identifier is an implicit variable that represents the value that is passed to the function when it is invoked.

Once compiled the function object is assigned to the variable `square` as any other variable assignments shown previously. 
To invoke the closure execution use the special method `call` or just use the round parentheses to specify the closure parameter(s). 
For example:

[cmd,groovy,linenums]
----
assert square.call(5) == 25
assert square(9) == 81
----

This is not very interesting until we find that we can pass the function `square` as an argument to other functions or methods. 
Some built-in functions take a function like this as an argument. One example is the `collect` method on lists:

[cmd,groovy,linenums]
----
x = [ 1, 2, 3, 4 ].collect(square)
println x
----

It prints:

[cmd,groovy,linenums]
----
[ 1, 4, 9, 16 ]
----

By default, closures take a single parameter called `it`, to give it a different name use the `->` syntax. For example:

[cmd,groovy,linenums]
----
square = { num -> num * num }
----

Itâ€™s also possible to define closures with multiple, custom-named parameters.

For example, the method `each()` when applied to a map can take a closure with two arguments, to which it passes the _key-value_ 
pair for each entry in the map object. For example:

[cmd,groovy,linenums]
----
printMap = { a, b -> println "$a with value $b" }
values = [ "Yue" : "Wu", "Mark" : "Williams", "Sudha" : "Kumari" ]
values.each(printMap)
----

It prints:

[cmd,groovy,linenums]
----
Yue with value Wu
Mark with value Williams
Sudha with value Kumari
----

A closure has two other important features. First, it can access and _modify_ variables in the scope where it is defined.

Second, a closure can be defined in an _anonymous_ manner, meaning that it is not given a name, and is defined in the place 
where it needs to be used.

As an example showing both these features, see the following code fragment:

[cmd,groovy,linenums]
----
result = 0  // <1>
values = ["China": 1 , "India" : 2, "USA" : 3] // <2>   
values.keySet().each { result += values[it] }  // <3>   
println result
----

<1> Define a global variable.
<2> Define a map object.
<3> Invoke the each method passing closure object which modifies the result variable.

Learn more about closures in the http://groovy-lang.org/closures.html[Groovy documentation].

== More resources

The complete Groovy language documentation is available at this http://groovy-lang.org/documentation.html#languagespecification[link].

A great resource to master Apache Groovy syntax is https://www.manning.com/books/groovy-in-action-second-edition[Groovy in Action].